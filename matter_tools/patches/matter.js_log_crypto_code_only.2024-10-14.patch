diff --git a/packages/general/src/crypto/Crypto.ts b/packages/general/src/crypto/Crypto.ts
index b3f7fcb13..06d370a38 100644
--- a/packages/general/src/crypto/Crypto.ts
+++ b/packages/general/src/crypto/Crypto.ts
@@ -11,6 +11,9 @@ import { MatterError, NoProviderError } from "../MatterError.js";
 import { Endian } from "../util/Bytes.js";
 import { DataReader } from "../util/DataReader.js";
 import { PrivateKey } from "./Key.js";
+import { Logger } from "../log/Logger.js";
+
+const logger = Logger.get("Crypto");

 export const ec = {
     p256,
@@ -35,12 +38,36 @@ export abstract class Crypto {
     };

     abstract encrypt(key: Uint8Array, data: Uint8Array, nonce: Uint8Array, aad?: Uint8Array): Uint8Array;
-    static readonly encrypt = (key: Uint8Array, data: Uint8Array, nonce: Uint8Array, aad?: Uint8Array): Uint8Array =>
-        Crypto.get().encrypt(key, data, nonce, aad);
+
+    static readonly encrypt = (key: Uint8Array, data: Uint8Array, nonce: Uint8Array, aad?: Uint8Array): Uint8Array => {
+        const result = Crypto.get().encrypt(key, data, nonce, aad);
+
+        // Convert key, nonce, and aad to hex strings
+        const keyString = utils.bytesToHex(key);
+        const nonceString = utils.bytesToHex(nonce);
+        const aadString = aad ? utils.bytesToHex(aad) : undefined;
+
+        // Log the converted values
+        logger.debug(`CRYPTOGRAPHIC_KEY_MATERIAL Key: ${keyString}, Nonce: ${nonceString}, AAD: ${aadString}`);
+
+        return result;
+    };

     abstract decrypt(key: Uint8Array, data: Uint8Array, nonce: Uint8Array, aad?: Uint8Array): Uint8Array;
-    static readonly decrypt = (key: Uint8Array, data: Uint8Array, nonce: Uint8Array, aad?: Uint8Array): Uint8Array =>
-        Crypto.get().decrypt(key, data, nonce, aad);
+
+    static readonly decrypt = (key: Uint8Array, data: Uint8Array, nonce: Uint8Array, aad?: Uint8Array): Uint8Array => {
+        const result = Crypto.get().decrypt(key, data, nonce, aad);
+
+        // Convert key, nonce, and aad to hex strings
+        const keyString = utils.bytesToHex(key);
+        const nonceString = utils.bytesToHex(nonce);
+        const aadString = aad ? utils.bytesToHex(aad) : undefined;
+
+        // Log the converted values
+        logger.debug(`CRYPTOGRAPHIC_KEY_MATERIAL Key: ${keyString}, Nonce: ${nonceString}, AAD: ${aadString}`);
+
+        return result;
+    };

     abstract getRandomData(length: number): Uint8Array;
     static readonly getRandomData = (length: number): Uint8Array => Crypto.get().getRandomData(length);
@@ -68,8 +95,17 @@ export abstract class Crypto {
     };

     abstract ecdhGeneratePublicKey(): { publicKey: Uint8Array; ecdh: any };
-    static readonly ecdhGeneratePublicKey = (): { publicKey: Uint8Array; ecdh: any } =>
-        Crypto.get().ecdhGeneratePublicKey();
+    static readonly ecdhGeneratePublicKey = (): { publicKey: Uint8Array; ecdh: any } => {
+        const result = Crypto.get().ecdhGeneratePublicKey();
+
+        // Convert publicKey to hex string
+        const publicKeyString = utils.bytesToHex(result.publicKey);
+
+        // Log the converted values
+        logger.debug(`CRYPTOGRAPHIC_KEY_MATERIAL ECDH Generate PublicKey: ${publicKeyString}`);
+
+        return result;
+    };

     abstract ecdhGeneratePublicKeyAndSecret(peerPublicKey: Uint8Array): {
         publicKey: Uint8Array;
@@ -81,8 +117,17 @@ export abstract class Crypto {
         Crypto.get().ecdhGeneratePublicKeyAndSecret(peerPublicKey);

     abstract ecdhGenerateSecret(peerPublicKey: Uint8Array, ecdh: any): Uint8Array;
-    static readonly ecdhGenerateSecret = (peerPublicKey: Uint8Array, ecdh: any): Uint8Array =>
-        Crypto.get().ecdhGenerateSecret(peerPublicKey, ecdh);
+    static readonly ecdhGenerateSecret = (peerPublicKey: Uint8Array, ecdh: any): Uint8Array => {
+        const result = Crypto.get().ecdhGenerateSecret(peerPublicKey, ecdh);
+
+        // Convert peerPublicKey to hex string
+        const peerPublicKeyString = utils.bytesToHex(peerPublicKey);
+
+        // Log the converted values
+        logger.debug(`CRYPTOGRAPHIC_KEY_MATERIAL ECDH Generate Secret PeerPublicKey: ${peerPublicKeyString}, ECDH: ${ecdh}`);
+
+        return result;
+    };

     abstract hash(data: Uint8Array | Uint8Array[]): Uint8Array;
     static readonly hash = (data: Uint8Array | Uint8Array[]): Uint8Array => Crypto.get().hash(data);
@@ -93,7 +138,18 @@ export abstract class Crypto {
         salt: Uint8Array,
         iteration: number,
         keyLength: number,
-    ): Promise<Uint8Array> => Crypto.get().pbkdf2(secret, salt, iteration, keyLength);
+    ): Promise<Uint8Array> => {
+        const result = Crypto.get().pbkdf2(secret, salt, iteration, keyLength);
+
+        // Convert secret and salt to hex strings
+        const secretString = utils.bytesToHex(secret);
+        const saltString = utils.bytesToHex(salt);
+
+        // Log the converted values
+        logger.debug(`CRYPTOGRAPHIC_KEY_MATERIAL PBKDF2 Secret: ${secretString}, Salt: ${saltString}, Iteration: ${iteration}, KeyLength: ${keyLength}`);
+
+        return result;
+    };

     abstract hkdf(secret: Uint8Array, salt: Uint8Array, info: Uint8Array, length?: number): Promise<Uint8Array>;
     static readonly hkdf = (
@@ -101,7 +157,19 @@ export abstract class Crypto {
         salt: Uint8Array,
         info: Uint8Array,
         length?: number,
-    ): Promise<Uint8Array> => Crypto.get().hkdf(secret, salt, info, length);
+    ): Promise<Uint8Array> => {
+        const result = Crypto.get().hkdf(secret, salt, info, length);
+
+        // Convert secret, salt, and info to hex strings
+        const secretString = utils.bytesToHex(secret);
+        const saltString = utils.bytesToHex(salt);
+        const infoString = utils.bytesToHex(info);
+
+        // Log the converted values
+        logger.debug(`CRYPTOGRAPHIC_KEY_MATERIAL HKDF Secret: ${secretString}, Salt: ${saltString}, Info: ${infoString}, Length: ${length}`);
+
+        return result;
+    };

     abstract hmac(key: Uint8Array, data: Uint8Array): Uint8Array;
     static readonly hmac = (key: Uint8Array, data: Uint8Array): Uint8Array => Crypto.get().hmac(key, data);
diff --git a/packages/protocol/src/session/SecureSession.ts b/packages/protocol/src/session/SecureSession.ts
index d7ef2f2eb..dd5eefa95 100644
--- a/packages/protocol/src/session/SecureSession.ts
+++ b/packages/protocol/src/session/SecureSession.ts
@@ -24,7 +24,7 @@ import { MessageCounter } from "../protocol/MessageCounter.js";
 import { MessageReceptionStateEncryptedWithoutRollover } from "../protocol/MessageReceptionState.js";
 import { Session, SessionParameterOptions } from "./Session.js";
 import { type SessionManager } from "./SessionManager.js";
-
+import * as utils from "@noble/curves/abstract/utils";
 const logger = Logger.get("SecureSession");

 const SESSION_KEYS_INFO = Bytes.fromString("SessionKeys");
@@ -86,6 +86,14 @@ export class SecureSession extends Session {
         const decryptKey = isInitiator ? keys.slice(16, 32) : keys.slice(0, 16);
         const encryptKey = isInitiator ? keys.slice(0, 16) : keys.slice(16, 32);
         const attestationKey = keys.slice(32, 48);
+
+        // Convert peerNodeId to a 64 bit hex string with zero padding to the left
+        const peerNodeIdString = peerNodeId.toString(16).padStart(16, "0");
+
+        // Convert fabric?.fabricId to a 64 bit hex string with zero padding to the left
+        const fabricIdString = fabric?.fabricId?.toString(16).padStart(16, "0");
+        logger.debug(`CRYPTOGRAPHIC_KEY_MATERIAL Session keys for ${isResumption ? "resumption" : "establishment"}: decryptKey=${utils.bytesToHex(decryptKey)}, encryptKey=${utils.bytesToHex(encryptKey)}, attestationKey=${utils.bytesToHex(attestationKey)}, peerNodeId=${peerNodeIdString}, peerSessionId=${peerSessionId.toString()},  id=${id.toString()}, fabric=${fabricIdString}`, );
+
         return new SecureSession({
             manager,
             id,
